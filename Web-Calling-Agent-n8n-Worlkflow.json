{
  "name": "Web-Calling-Agent",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "6e9584ad-91bb-47a7-aaa5-142a374d3444",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        0,
        0
      ],
      "id": "0a575f62-9aa5-431c-9e93-df7f812c42c1",
      "name": "Webhook",
      "webhookId": "6e9584ad-91bb-47a7-aaa5-142a374d3444"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.query.toolCallName }}",
                    "rightValue": "checkAvailability",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "a6a19733-385c-4da6-a5f6-6e5f882f4393"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "f6e709a3-749c-474c-80f2-1f0c92977d4a",
                    "leftValue": "={{ $json.query.toolCallName }}",
                    "rightValue": "bookAppointment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        208,
        0
      ],
      "id": "26fe25ed-3992-43e5-9af4-daf23573d7ed",
      "name": "Switch"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "0c8c5fe7-f9ac-466e-a7c7-350dbcfd403f",
              "leftValue": "={{ $json.body.preferredTime }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        416,
        -96
      ],
      "id": "04eebce2-8d0d-439b-b34f-63ff2ec98a19",
      "name": "If"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        816,
        -48
      ],
      "id": "13000b47-a1aa-4f31-a7ea-78d9e82c2cdd",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "EVqQ8xoUzdeSkzwK",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"start\": \"2025-10-27T09:00:00Z+5:30\",\n  \"end\": \"2025-10-27T17:00:00Z+5:30\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1072,
        -48
      ],
      "id": "32dc901c-eda3-4d47-be94-3345a9f4009c",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=The current date is {{$now}}\n\n## Task\nConvert relative dates (e.g., \"next Monday\") to ISO 'YYYY-\nMM-DDTHH:MM:SSZ\nWhen converting time please apply an offset like this: 2025-\n08-12T09:00:00+05:30\n\nThe time you need to convert: {{ $json.body.preferredTime }}\n\n## Output\n- Always set the start time to 9AM and end time to 5PM\nOutput the result without explanation",
        "hasOutputParser": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        864,
        -240
      ],
      "id": "b5288e1e-e990-460a-b6b3-c8746d82b9f0",
      "name": "Check for desired day"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        816,
        304
      ],
      "id": "017b6e6f-449d-4757-b463-b9738504467c",
      "name": "Google Gemini Chat Model1",
      "credentials": {
        "googlePalmApi": {
          "id": "EVqQ8xoUzdeSkzwK",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"start\": \"2025-10-27T09:00:00Z+5:30\",\n  \"end\": \"2025-10-27T17:00:00Z+5:30\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1024,
        304
      ],
      "id": "da749e34-770f-4028-8eb2-5011716f0d95",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=The current date is {{$now}}\n\n## Task\n- Output the date of tomorrow 9AM and tomorrow + 1 week 5PM\nin a 2025-08-12T13:00:00+05:30 format\n\n## Output\nOutput the result without explanation",
        "hasOutputParser": true,
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        848,
        128
      ],
      "id": "21506305-4586-46ac-96e1-b0f17a07f3bc",
      "name": "Check for upcoming week"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1552,
        48
      ],
      "id": "9a050d26-fbea-49e0-a8f5-b8b28eb19ab6",
      "name": "Merge"
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "nandinikatta35@gmail.com",
          "mode": "list",
          "cachedResultName": "nandinikatta35@gmail.com"
        },
        "timeMin": "={{ $json.output.start.split('+')[0] }}",
        "timeMax": "={{ $json.output.end.split('+')[0] }}",
        "options": {
          "outputFormat": "bookedSlots"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        1760,
        48
      ],
      "id": "8fd3a140-951f-4d37-a493-5620e6f50011",
      "name": "Get availability in a calendar",
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "8CUZ4Vj0fbnu8s6L",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1968,
        48
      ],
      "id": "c6007543-8b26-4544-8419-709b8af1926e",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "0471578a-f91e-47c9-ab0e-5681efd566ec",
              "leftValue": "={{ $json.data[0] }}",
              "rightValue": "",
              "operator": {
                "type": "object",
                "operation": "empty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2176,
        48
      ],
      "id": "ee521343-3557-4602-b443-5f5cb01476dc",
      "name": "If Free"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"result\": \"The desired date is free\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2384,
        -48
      ],
      "id": "f94bc976-7ed8-4916-8bca-fe566741fe63",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "function findFreeOneHourSlots (bookedSlots, workingHoursStart = '09:00', workingHoursEnd = '17:00') {\n\n// Fixed timezone\nconst timezone = '+05:30';\n\n// Parse timezone string to get heurs and minutes\nfunction parseTimezone(tz) {\n//timezone format: \"+01:00\" or \"-05:30\"\nconst sign = tz[0] === '+' ? 1 : -1;\nconst hours = parseInt(tz.slice(1, 3));\nconst minutes = parseInt(tz.slice(4, 6));\nreturn { sign, hours, minutes };\n}\n\n// Convert time string (e... \"09:00\") to Date object\nfunction parseTime(timeStr, baseISOString) {\nconst parts = timeStr.split(':');\nconst hours = parseInt(parts[0]);\nconst minutes = parseInt(parts[1]);\n// Get the date part from the 150 string\nconst datePart = baseISOString.split('T')[0];\n// Build 150 string with the desired time and fixed timezone\nconst isoString = `${datePart}T${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:00${timezone}`;\n\nreturn new Date(isoString);\n}\n\n//Convert Date object back to 150 string with timezone\nfunction toISO(date) {\nconst tz = parseTimezone(timezone);\nconst offsetMs = (tz.hours * 60 + tz.minutes) * 60 * 1000 * tz.sign;\nconst adjustedDate = new Date(date.getTime() + offsetMs);\nconst year = adjustedDate.getUTCFullYear();\nconst month = String(adjustedDate.getUTCMonth() + 1).padStart(2, '0');\nconst day = String(adjustedDate.getUTCDate()).padStart(2, '0');\nconst hour = String(adjustedDate.getUTCHours()).padStart(2, '0');\nconst minute = String(adjustedDate.getUTCMinutes()).padStart(2, '0');\nconst second = String(adjustedDate.getUTCSeconds()).padStart(2, '0');\nreturn `${year}-${month}-${day}T${hour}:${minute}:${second}${timezone}`;\n}\n// Get reference date from first booking or use current date\nconst referenceDate = bookedSlots.length > 0 ? bookedSlots[0].start : new Date().toISOString();\n// Parse working hours (og 09:00-17:00)\nconst workStart = parseTime (workingHoursStart, referenceDate);\nconst workEnd = parseTime (workingHoursEnd, referenceDate);\n\nconst booked = bookedSlots.map(slot => ({ start: new Date(slot.start), end: new Date(slot.end) })).sort((a, b) => a.start - b.start);\n// Merge overlapping bookings\nconst merged = [];\nfor (const slot of booked) {\nif (merged.length === 0 || merged[merged.length-1].end < slot.start) {\nmerged.push({ start: new Date(slot.start), end: new Date(slot.end) });\n} else {\nmerged [merged.length - 1].end = new Date(Math.max(merged[merged.length-1].end, slot.end));\n}\n}\n// Find free time intervals\nconst freeIntervals = [];\nlet currentTime = new Date(workStart);\nfor (const slot of merged) {\n  if (currentTime < slot.start) {\n    freeIntervals.push({ start: new Date(currentTime), end: new Date(slot.start) });\n  }\n  currentTime = new Date(Math.max(currentTime, slot.end));\n}\n\nif (currentTime < workEnd) {\nfreeIntervals.push({ start: new Date(currentTime), end: new Date(workEnd) });\n}\n// Split free intervals into 1-hour slots\nconst oneHourSlots = [];\nconst oneHour = 60 * 60 * 1000;\nfor (const interval of freeIntervals) {\nif (interval.end - interval.start >= oneHour) {\nlet slotStart = new Date(interval.start);\n// Ensure slot END is within working hours (must end at or before workEnd]\nwhile (slotStart.getTime() + oneHour <= interval.end.getTime() && slotStart.getTime() + oneHour <= workEnd.getTime()) {\nconst slotEnd = new Date(slotStart.getTime() + oneHour);\noneHourSlots.push({\nstart: toISO(slotStart),\nend: toISO(slotEnd)\n});\nslotStart = new Date(slotEnd);\n}\n}\n}\n  return oneHourSlots;\n}\n\nconst result = findFreeOneHourSlots($input.first().json.data);\nreturn {result}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2384,
        144
      ],
      "id": "09227369-7816-42f7-87db-c4973fd5c349",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2608,
        144
      ],
      "id": "c712d351-0893-4557-88c2-52d7c6570264",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "nandinikatta35@gmail.com",
          "mode": "list",
          "cachedResultName": "nandinikatta35@gmail.com"
        },
        "start": "={{ $json.body.dateTime.slice(0, -1).split('+')[0] }}",
        "end": "={{ $json.body.dateTime\n  .toDateTime()\n  .plus({ hour: 1 })\n  .toISO({ suppressMilliseconds: true, includeOffset: false })\n }}",
        "additionalFields": {
          "description": "=Email: {{ $json.body.email }}",
          "summary": "={{ $json.body.name }} - {{ $json.body.event }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        432,
        224
      ],
      "id": "83d90b98-5a5d-45f3-b3d1-994ed048a876",
      "name": "Create an event",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "8CUZ4Vj0fbnu8s6L",
          "name": "Google Calendar account"
        }
      }
    },
    {
      "parameters": {
        "sendTo": "={{ $json.description.split(\":\")[1].trim() }}",
        "subject": "=Appointment confirmation email.",
        "message": "=<p>Hello {{ $json.summary.split(\"-\")[1].trim() }},</p>\n\n<p>\nThis is to confirm your <strong>{{ $json.summary.split(\"-\")[1].trim() }}</strong> scheduled as per the details below:\n</p>\n\n<p>\nðŸ“… <strong>Date:</strong> {{ $json.start.dateTime.split(\"T\")[0] }}<br>\nðŸ•’ <strong>Time:</strong> {{ $json.start.dateTime.split(\"T\")[1].split(\"+\")[0] }}\n</p>\n\n<p>We look forward to speaking with you.</p>\n\n<p>\nWarm regards,<br>\n<strong>{{ $json.creator.email.split(\"@\")[0].replace(/[0-9]/g, \"\").replace(/\\b\\w/g, c => c.toUpperCase()) }}</strong>\n</p>\n",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        704,
        512
      ],
      "id": "a93aae15-6b91-4ebb-bb4d-ea8f5c10eb4f",
      "name": "Send a message",
      "webhookId": "79a80ac4-2290-4186-afa0-1b842e7a6ddf",
      "credentials": {
        "gmailOAuth2": {
          "id": "2BBkjHu5GqCkoM7u",
          "name": "Gmail account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create an event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Check for desired day",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check for upcoming week",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Check for desired day",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Check for desired day",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Check for upcoming week",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Check for upcoming week",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Check for desired day": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for upcoming week": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Get availability in a calendar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get availability in a calendar": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "If Free",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Free": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create an event": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "035d48e9-8a69-4550-8d1b-77782fc4999a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "b0c81b58592052ac3272458034f7db34f9b2418b1884e00c9dc167cb7bbaf8fd"
  },
  "id": "y5p9iYiBcthD59Qy",
  "tags": []
}